
## 所有权

所有的程序都必须和计算机内存打交道，如何从内存中申请空间来存放程序的运行内容，如何在不需要的时候释放这些空间，成了重中之重，也是所有编程语言设计的难点之一。在计算机语言不断演变过程中，出现了三种流派：
- 垃圾回收机制(GC)，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
- 手动管理内存的分配和释放, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
- 通过所有权来管理内存，编译器在编译时会根据一系列规则进行检查
其中 Rust 选择了第三种，最妙的是，这种检查只发生在编译期，因此对于程序运行期，不会有任何性能上的损失。

在正式进入主题前，先来一个预热知识。
### 栈(Stack)与堆(Heap)
栈（Stack）和堆（Heap）是在编程语言中用于内存分配的两种重要的数据结构，特别在像 Rust 这样的系统编程语言中，它们的使用对程序的性能和行为有着显著影响。下面是关于栈和堆的详细解释及它们的性能差异和在 Rust 中的特殊意义。

- 栈
工作原理: 栈遵循后进先出（LIFO, Last-In-First-Out）的原则。可以想象成一叠盘子，只能从顶部添加或移除盘子。
内存分配: 栈的数据必须占用已知且固定的内存大小。当新数据入栈时，它会被放置在栈顶，而从栈中取出数据时，数据也是从栈顶开始移除。
速度: 栈上的内存分配非常快，因为它不涉及复杂的内存管理或系统调用。栈只需要移动栈顶的指针即可。
- 堆
工作原理: 堆用于存储大小未知或可能变化的数据。当需要在堆上分配内存时，操作系统会寻找一块足够大的未使用空间，标记为已使用，并返回一个指向该空间的指针。
内存分配: 分配在堆上的数据通过指针进行访问，这些指针通常存储在栈上。因为堆是一个更为复杂且缺乏组织的数据结构，所以分配和管理堆内存比栈更慢且更复杂。
性能: 在堆上分配内存比栈上慢，因为它涉及到查找足够空间、可能的系统调用以及管理内存分配的额外工作。
- 性能区别
栈上分配内存: 快速且高效，因为它只涉及移动栈顶指针。
堆上分配内存: 较慢，因为需要进行内存查找和可能的系统调用。

### 所有权原则
1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
3. 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)


### 克隆(深拷贝)
Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何自动的复制都不是深拷贝，可以被认为对运行时性能影响较小。
如果我们确实需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的方法。
```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);

```
这段代码能够正常运行，说明 s2 确实完整的复制了 s1 的数据。

### 拷贝(浅拷贝)
浅拷贝只发生在栈上，因此性能很高，在日常编程中，浅拷贝无处不在。
例如：

```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);

```

在 Rust 中，基本类型如整数、浮点数、布尔值和字符类型通常实现了 `Copy` 特性，这是因为这些类型通常存储在栈上，并且它们的大小在编译时已知，使得拷贝操作变得非常快速和高效。这就是为什么这些类型在被赋值给另一个变量后，原始变量依旧保持可用状态的原因。

### Rust 中的 `Copy` 特性

`Copy` 特性在 Rust 中的作用是允许类型实例在赋值时进行自动复制，而无需手动调用如 `clone` 方法这样的函数。当一个类型实现了 `Copy` 特性后，它的值在被赋给另一个变量时会被自动复制，使得原始值和新赋值都独立存在。

#### 可以自动实现 `Copy` 的条件

- 类型必须存储在栈上。
- 类型的所有部分（如字段）也必须实现了 `Copy`。

#### 常见的 `Copy` 类型

- **所有整数类型**，例如：`u8`, `i32`, `u64` 等。
- **布尔类型** (`bool`)，其值为 `true` 或 `false`。
- **所有浮点数类型**，例如：`f32`, `f64`。
- **字符类型** (`char`)。
- **元组**，但仅当其包含的所有字段类型也都是 `Copy` 的。例如，`(i32, i32)` 是 `Copy` 的，但 `(i32, String)` 不是，因为 `String` 不是 `Copy`。
- **不可变引用** (`&T`)，这使得引用可以在不影响原始数据的情况下被复制。然而，**可变引用** (`&mut T`) 不是 `Copy`，因为在 Rust 的安全机制中，同一时间只能有一个可变引用指向同一数据。

### 深浅拷贝的区别和影响

在 Rust 中，讨论深浅拷贝主要涉及到非 `Copy` 类型，比如 `String`、`Vec` 等，这些类型通常存储在堆上，其大小在编译时不确定，因此拷贝操作涉及到更复杂的内存管理。在这种情况下，`clone` 方法通常用于执行深拷贝，即复制数据本身，而不仅仅是指针。

对于实现了 `Copy` 的类型，如前所述，它们的拷贝可以视为栈上的“深拷贝”，因为赋值操作实际上是在复制值，而不是引用或指针。

## 引用与借用

在 Rust 中，**借用（Borrowing）** 是一种让你在不转移所有权的情况下，使用数据的方法。借用在 Rust 的内存安全保障中起到了核心作用，同时也使得数据的共享变得更加灵活而不牺牲安全性。
借用概念也是实际生活中思维的映射。比如你有一样东西，别人想用一下，可以从你这里借， 你可以借出。那“引用”概念又是什么呢？其实在 Rust 中，**借用和引用是一体两面**。你把东西借给别人用，也就是别人持有了对你这个东西的引用。这里你理解就好，后面我们会混用这两个词。

### 借用的基本概念

在 Rust 中，当你获取一个变量的引用时，你实际上是在“借用”这个变量。有两种类型的借用：

- **不可变借用（Immutable Borrow）**：通过 `&` 符号获得一个不可变的引用。在借用期间，原数据不可被修改。
- **可变借用（Mutable Borrow）**：通过 `&mut` 符号获得一个可变的引用。这允许你在借用期间修改数据。

### 作用域

一个所有权型变量的作用域是从它定义时开始到花括号结束。而引用型变量的作用域不是这样，引用型变量的作用域是从它定义起到它最后一次使用时结束。


### 借用的规则

Rust 中的借用必须遵守两个主要的规则：

1. **一个数据项只能有一个可变引用，或者多个不可变引用**：
   - 如果你有一个可变引用 `&mut`，则在该引用存活期间，不能再有其他的可变引用或不可变引用存在。
   - 如果你有一个不可变引用 `&`，则可以同时存在多个不可变引用，但不能有可变引用。

2. **引用的生命周期不能超过其所引用的数据的生命周期**：
   - 引用不能悬空，即引用的数据必须在引用之前存在，并且在引用结束后仍然存在。
   

### 借用的优势

借用使得 Rust 程序能够在无需复制数据的情况下安全地访问和修改数据。这减少了内存和计算开销，提高了程序的效率。同时，通过编译时的借用检查，Rust 确保了程序的内存安全，避免了数据竞争和悬空引用等常见的错误。

### 示例

以下是一个简单的 Rust 程序，展示了不可变和可变借用的用法：

```rust
fn main() {
    let mut x = 5;

    // 创建一个不可变引用
    let y = &x;
    println!("The value of x is: {}", y);

    // 创建一个可变引用
    let z = &mut x;
    *z += 1;
    println!("The value of x is: {}", z);
}
```

在这个例子中，`y` 是一个指向 `x` 的不可变引用，而 `z` 是一个指向 `x` 的可变引用。注意，这两个引用不会同时存在，因为这会违反借用的规则。
